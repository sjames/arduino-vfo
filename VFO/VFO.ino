/*
 * VFO for Radio experiments using Si5351 module.
 * Using the following libraries
 * https://github.com/brianlow/Rotary
 *  Si5351 https://github.com/etherkit/Si5351Arduino
 *  https://github.com/olikraus/u8g2
 *  Author: Sojan James <sojan dot james ampersand gmail dot com>
 *
 *  State machine built using Yakindu SCT https://www.itemis.com/en/yakindu/state-machine/
 *
 *  Copyright 2018, Sojan James
 *
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 *
 *  Connections:
 *  Si5351 module         Arduino Pin
 *     SDA -                 A4
 *     SCL -                 A5
 *
 *  SSD1306 display
 *     D0                    D10
 *     D1                    D09
 *     RES                   D13
 *     DC                    D11
 *     CS                    D12
 *
 *  Rotary
 *     CLK                   D2
 *     DT                    D3
 *     SWITCH                D4

 */

#include <Rotary.h>

/* SSD1306 display connected over SPI */
#include <SPI.h>
#include <Wire.h>

/* Si5351 https://github.com/etherkit/Si5351Arduino */
#include "si5351.h"

/* State machine generated by Yakindu C++ generator */
#include "yakindu-gen/Default.h"
#include "src/sc_types.h"

#include <U8g2lib.h>
#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif

U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 10, /* data=*/ 9, /* cs=*/ 12, /* dc=*/ 11, /* reset=*/ 13);

/* Rotary */
Rotary r = Rotary(2,3);

//static int gRotaryPos = 0;
static int g_rotary_pos = 0;
static int gButton = 4;



/* Si5351 */
Si5351 si5351(0x60);

/* State machine generated by Yakindu */
Default smVFO; /* Create an instance of the VFO state machine */

class SMCallback : public Default::DefaultSCI_OCB {
	void updateClock(sc_integer id);
	void updateDisplay();
	void enableClock(sc_integer id);
	void disableClock(sc_integer id);
};
SMCallback smcb;


void setup() {

  Serial.begin(57600);

  u8g2.begin();
  u8g2.setFlipMode(0);
  u8g2.setFontMode(0);	// Transparent
  u8g2.setDrawColor(1);
  u8g2.setFontDirection(0);
  u8g2.setFont(u8g2_font_crox3hb_tr);

  bool i2c_found = false;
  i2c_found = si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0);

  if (!i2c_found)
  {
    /* There was a problem detecting the IC ... check your connections */
    Serial.print("Si5351 not detected");
  } else {
    Serial.println("Si5351 Init done");
  }


  pinMode(gButton, INPUT);

  smVFO.setDefaultSCI_OCB(&smcb);
  smVFO.init(); /* Initialize it */
  smVFO.set_clock0ReqFreq(700000000);
  smVFO.set_clock1ReqFreq(1400000000);
  smVFO.set_clock2ReqFreq(350000000);
  smVFO.set_clock0Multiplier(100);
  smVFO.set_clock1Multiplier(100);
  smVFO.set_clock2Multiplier(100);

  smVFO.enter(); /* Enter the state machine to activate it */
  smVFO.runCycle(); /* Chance to initialize */
  updateDisplay();
//  smVFO.raise_eUpdateDisplay();
//  smVFO.runCycle(); /* Chance to initialize */

  //draw();

  PCICR |= (1 << PCIE2);
  PCMSK2 |= (1 << PCINT18) | (1 << PCINT19);
  sei();

}

/* 0 no button pressed      */
/* 1 - short press detected */
/* 2 - long press detected  */
unsigned char detectButtonPress() {
	static long buttonTimer = 0;
	static const  long longPressTime = 1000;

	static boolean buttonActive = false;
	unsigned char button = 0;
	if (digitalRead(gButton) == LOW) {

			if (buttonActive == false) {
				buttonActive = true;
				buttonTimer = millis();
			}
	} else {
		/* Button is not pressed */
		if(buttonActive) {

			/* Button was active and just got released */
			if( (millis() - buttonTimer) > longPressTime) {
				//Long press
				button = 2;

				//Serial.println(button);
			} else {
				// Short press
				button = 1;
				//Serial.println(button);
			}
			buttonActive = false;

		}
	}
	return button;
}


void loop() {

  char but = detectButtonPress();
  bool eventRaised = false;
  if(but == 1) {
	  smVFO.raise_eShortPress();
	  Serial.println(".");
	  eventRaised = true;
  } else if (but == 2) {
	  smVFO.raise_eLongPress();
	  Serial.println("_");
	  eventRaised = true;
  }

  int ticks = getRotaryTicks();
  if(ticks > 0) {
	  smVFO.raise_eClockWiseTick(ticks);
	  eventRaised = true;
	 // Serial.println("ClockWise");
  } else if (ticks < 0) {
	  smVFO.raise_eCounterClockWiseTick(-ticks);
	  eventRaised = true;
	 // Serial.println("CCW");
  }

  smVFO.runCycle();

  if(eventRaised) {
	  updateDisplay();
  }

}

#define ROW_SIZE  16
#define FREQ_XPOS 10
#define CLK0_YPOS (ROW_SIZE*2 - 2)
#define CLK1_YPOS (ROW_SIZE*3 - 2)
#define CLK2_YPOS (ROW_SIZE*4 - 2)

/*
 * 0 -> no movement
 * > 0 -> Clockwise
 * < 0 -> Counter clockwise
 */
int getRotaryTicks() {
	static int last_rotary_pos = 0;
	int ticks = 0;
	/* Cache the value */
	int rotary_pos = g_rotary_pos;
	ticks = rotary_pos - last_rotary_pos;
	last_rotary_pos = rotary_pos;
	return ticks;
}




/* Interrupt Handler for rotary */
ISR(PCINT2_vect) {
  unsigned char result = r.process();
  if (result == DIR_NONE) {
    // do nothing
  }
  else if (result == DIR_CW) {
   // Serial.println("ClockWise");
    g_rotary_pos += 1;

  }
  else if (result == DIR_CCW) {
    //Serial.println("CounterClockWise");
    g_rotary_pos -= 1;

  }
}


void SMCallback::updateClock(const sc_integer id)
{
	//Serial.print("Update clock:");
	//Serial.println(id);
	if(id == 0) {
		if(smVFO.get_clock0Freq() != smVFO.get_clock0ReqFreq() ) {
			si5351.set_freq((unsigned long int)smVFO.get_clock0ReqFreq(), SI5351_CLK0);
			//Serial.println(smVFO.get_clock0ReqFreq());
			smVFO.set_clock0Freq(smVFO.get_clock0ReqFreq());

		}
	} else if ( id == 1) {
		if(smVFO.get_clock1Freq() != smVFO.get_clock1ReqFreq() ) {
			si5351.set_freq((unsigned long int)smVFO.get_clock1ReqFreq(), SI5351_CLK1);
			smVFO.set_clock1Freq(smVFO.get_clock1ReqFreq());
			//Serial.println(smVFO.get_clock1ReqFreq());
		}
	} else if ( id == 2) {
		if(smVFO.get_clock2Freq() != smVFO.get_clock2ReqFreq() ) {
			si5351.set_freq((unsigned long int)smVFO.get_clock2ReqFreq(), SI5351_CLK2);
			smVFO.set_clock2Freq(smVFO.get_clock2ReqFreq());
			//Serial.println(smVFO.get_clock2ReqFreq());
		}
	}
}

void SMCallback::updateDisplay() {
	::updateDisplay();
}


static unsigned char adjPosFromMultiplier(unsigned long multiplier)
{
	unsigned char pos = 0;
	while(! (multiplier % 10)) {
		pos++;
		multiplier = multiplier / 10;
	}
	return pos;
}


static void displayFreq(unsigned long f, unsigned long multiplier, bool showMultiplier) {
	char buf[12];
	sprintf(buf,"%08lu.%02lu",f/100,f%100);

	if(!showMultiplier) {
		u8g2.print(buf);
	} else {
		unsigned char len = strlen(buf)-1;
		unsigned char hilitepos= len - adjPosFromMultiplier(multiplier);
		if(hilitepos<=8) {
			hilitepos--;
		}

		len -= hilitepos-1;
		u8g2.write((unsigned char*)buf,hilitepos);
		u8g2.setDrawColor(0);
		len -= 1;
		u8g2.write((unsigned char*)buf+hilitepos,1);
		u8g2.setDrawColor(1);
		u8g2.write((unsigned char*)buf+hilitepos+1,len);
	}

	//drawAdjustPosition(adjPosFromMultiplier(multiplier));

}

static void updateDisplay()
{
	//Serial.println("Update display");
	bool showMultiplier = false;
	bool showIncrDecr = false;
	if(smVFO.isStateActive(Default::main_region_main_r1_freq0bar_clk0_SetMultiplier)  ||
				smVFO.isStateActive(Default::main_region_main_r1_freq1bar_clk1_SetMultiplier) ||
				smVFO.isStateActive(Default::main_region_main_r1_freq2bar_clk2_SetMultiplier)
				) {
					showMultiplier = true;
				}

	if(smVFO.isStateActive(Default::main_region_main_r1_freq0bar_clk0_Selected)  ||
			smVFO.isStateActive(Default::main_region_main_r1_freq1bar_clk1_Selected) ||
			smVFO.isStateActive(Default::main_region_main_r1_freq2bar_clk2_Selected)
			) {
				showIncrDecr = true;
	}
	u8g2.firstPage();
	  do {
		u8g2.setCursor(0, 13);
		//u8g2.setFont(u8g2_font_5x7_mr);
		u8g2.print( F("vfo 0.9"));
		//u8g2.setFont(u8g2_font_crox3hb_tr);
		u8g2.setCursor(0, CLK0_YPOS);
		u8g2.print(F("0:"));

		displayFreq(smVFO.get_clock0ReqFreq(),smVFO.get_clock0Multiplier(),showMultiplier);

		if(smVFO.isStateActive(Default::Generator_Running_CLK0_On)){
			u8g2.drawBox(120,20,6,6);
		}
		u8g2.setCursor(0, CLK1_YPOS);
		u8g2.print(F("1:"));

		displayFreq(smVFO.get_clock1ReqFreq(),smVFO.get_clock1Multiplier(),showMultiplier);
		if(smVFO.isStateActive(Default::Generator_Running_CLK1_On)){
			u8g2.drawBox(120,36,6,6);
		}
		u8g2.setCursor(0, CLK2_YPOS);
		u8g2.print(F("2:"));
		displayFreq(smVFO.get_clock2ReqFreq(),smVFO.get_clock2Multiplier(),showMultiplier);
		if(smVFO.isStateActive(Default::Generator_Running_CLK2_On)){
			u8g2.drawBox(120,52,6,6);
		}

		if(smVFO.isStateActive(Default::main_region_main_r1_freq0bar)) {
			u8g2.drawRFrame(0,CLK0_YPOS-ROW_SIZE+2, 128, 16,3);
		}
		if (smVFO.isStateActive(Default::main_region_main_r1_freq1bar)) {
			u8g2.drawRFrame(0,CLK1_YPOS-ROW_SIZE+2, 128, 16,3);
		}
		if (smVFO.isStateActive(Default::main_region_main_r1_freq2bar)) {
			u8g2.drawRFrame(0,CLK2_YPOS-ROW_SIZE+2, 128, 16,3);
		}

		if(showIncrDecr) {
			u8g2.setCursor(110, 13);
			u8g2.print( F("<>"));
		}
	  } while ( u8g2.nextPage() );

}
void SMCallback::enableClock(const sc_integer id)
{
	if(id == 0) {
		si5351.output_enable(SI5351_CLK0, 1);
	} else if (id == 1) {
		si5351.output_enable(SI5351_CLK1, 1);
	} else if (id == 2) {
		si5351.output_enable(SI5351_CLK2, 1);
	}
}
void SMCallback::disableClock(const sc_integer id)
{
	if(id == 0) {
			si5351.output_enable(SI5351_CLK0, 0);
		} else if (id == 1) {
			si5351.output_enable(SI5351_CLK1, 0);
		} else if (id == 2) {
			si5351.output_enable(SI5351_CLK2, 0);
		}
}
